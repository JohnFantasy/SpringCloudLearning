# 前置知识
# 第一章 并发编程中的三个问题

- 可见性
  - 一个线程对一个变量进行修改，另一个线程能立即得到这个变量修改后的最新值
  - 并发编程时，会出现可见性问题：即当一个线程修改了共享变量的值，其他线程可能不会立即得到该变量的最新值
- 原子性
  - 在一次或多次操作中，要么所有的操作都执行并且不会受其他因素的干扰而中断，要么所有的操作都不执行。
- 有序性
  - 程序代码在执行过程中的先后顺序，由于Java虚拟机在编译期及运行期的优化，导致代码的执行顺序并不一定就是开发者编写代码时的顺序。

# 第二章 Java内存模型

## 计算机结构

### 目标

	- 学习计算机主要组成部分
	- 学习缓存的作用

### 计算机结构简介

冯诺依曼：提出计算机5大部分组成：输入设备、输出设备、存储器、控制器、运算器

### CPU

### 内存

​	内存读写速度与CPU运算速度之间的差距成为计算机性能瓶颈，为了解决这个问题，设计了缓存

### 缓存

缓存内置于CPU中

L1 最靠近CPU的缓存，容量最小，速度最快，每个CPU内核上都有一个L1缓存

L2级缓存，速度比L1慢些，一般情况下每个核心上都有一个L2缓存

L3级缓存，是三级缓存中最大的一级，同时也是缓存中最慢的一级，在同一个CPU插槽之间的CPU核心共享一个L3缓存

### 磁盘

### 输入输出设备

## Java内存模型

### 目标

学习Java内存模型的概念和作用

### Java内存模型的概念

Java Memory Model (JMM)

- 主内存（共享内存）
  - 所有线程共享的内存
- 工作内存
  - 线程私有的内存

### Java内存模型的作用

Java内存模型是一套在多线程读写共享数据时，对共享数据的可见性、有序性和原子性的规则和保障。

synchronized 

volatile

### java内存模型和CPU硬件内存架构的关系

![关系](image-20211229181515956.png)

### 主内存与工作内存之间的交互

![image-20211230150900723](image-20211230150900723.png)

- 如果执行lock操作，则会清空线程工作内存中此变量的值
- 对一个变量执行unlock操作之前，一定会先把此变量同步到主内存中

### 总结

在JMM中，通过以下8个原子操作来保证主内存和工作内存之间的数据交互：

lock->read->load->use->assign->store->write->unlock

# 第三章 synchronized保证三大特性

synchronized能保证同一时刻只有一个线程执行该段代码，以达到保证并发安全的效果

``` Java
synchronized(锁对象){
	//受保护资源
}
```

## synchronized保证原子性

``` Java

```
synchronized保证原子性的原理：
对代码块使用synchronized修饰后，保证同一时间只有一个线程能执行该代码块，从而不会出现线程安全问题。



## synchronized保证可见性
## synchronized保证有序性


# 第四章 synchronized的特性

# 第五章 synchronized原理



# 浅析synchronized关键字
## 修饰实例方法
## 修饰静态方法
## 修饰代码块
# synchronized关键字的使用
# synchronized关键字底层原理
# 锁的升级流程
# synchronized关键字修饰方法的底层原理